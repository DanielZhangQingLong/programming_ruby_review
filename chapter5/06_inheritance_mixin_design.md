## Inheritance, Mixins, and Design

> 继承和 Mixin 都可以把代码从一个地方高效的注入到多个类. 那么, 具体什么情况下用什么呢?

> 这就要看情况而定. 多年来开发者已经总结出很清晰的指导方针来帮助我们做决定.

> 首先, 我们看看子类. 类在 Ruby 中是与类型相关的. 看到 `"cat"` 你会很自然知道它使 string 类型, [1, 2] 很显然是数组. 还有一种方式来说`"cat"` 是 string, `[1, 2]` 是数组, 当我们创建自己的类时可以想成是谓这种语言增加了一种新的类型. 当我们创建不管是 Ruby 内建的类还是我们已经创建的类的子类时, 我们就在创建子类型.

> 现今, 关于类型的理论的研究有很多. 其中一个很著名的是 "Liskov Substitution principle(里氏替换原则)". 让 q(x) 为 T 类 的 对象 x 的属性, 那么 q(y) 也是真的, 对象 y 属于 S 型的( S 是 T 的子类型 ). 就是说你可以替换掉一个子类对象, 不管在哪, 使用父类对象. 还有一种方法来看待这个问题, 我们可以说子类对象是父类的一种. 我们经常这样说: 汽车属于车类, 猫是动物... 也就是说猫可以做动物做的任何事情.

> 所以当你设计系统时寻找子类关系时, 要留意 is-a 的关系.

> 但是现实世界, 没有很多 is a 的关系. 反而很多 has a 和 uses a 的关系. 现实世界是组成的而不是继承的.

> 过去, 我们倾向于在编程时掩盖事实. 因为继承是唯一分享代码的可用模式, 我们偷懒, 说这样一些话, "My Person class is a subclass of my DatabaseWrapper class"(事实上, rails 框架就犯了这个错误) 但是 一个人根本不是 database wrapper 对象. person 对象使用 wrapper 来提高的持久化服务.

> 这个仅仅是理论问题吗? 不是, 继承表示一种两个组件之间极其紧密的联系. 改变父类, 你就是在冒险破坏子类. 更糟糕的是, 如果一些代码使用子类对象, 又依赖父类的方法, 那么所有的代码都会被破坏. 父类代码问题通过子类影响到了其他的代码. 对于已经设计良好的程序来说, 改变代码就成了严重的问题.

> 这就是我把继承从设计中移除的原因. 反而, 我们需要使用组合, 不管是 A uses a B, 或者 A has a B. 我们持久化的 Person 对象不应该去子类化一个 DataWrapper, 而是, 一个建立一个database 类的 wrapper 对象 并且 使用哪个来保存并存储自己.

> 但是这还会让代码很乱. 那就需要  metaprogramming 和 mixin 的组合来解决了, 可以这样做:

```ruby

class Person
  include Persistable
end

取代:

class Person < DataWrapper
end

```

> 如果你刚刚接触到 OO 编程, 这样的讨论很遥远也很抽象. 但是如果你开始写更大的程序, 我们强烈建议你考虑这些问题. 使用 inheritance 要三思而后行. 试一下更酷的方法--- mixin 让你写出解耦更加灵活的代码.
